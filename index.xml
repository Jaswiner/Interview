<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Home on 面试题</title>
    <link>https://jaswine.com/interview/</link>
    <description>Recent content in Home on 面试题</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sat, 04 May 2019 10:44:39 +0800</lastBuildDate>
    
	<atom:link href="https://jaswine.com/interview/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Nginx</title>
      <link>https://jaswine.com/interview/docs/server/nginx/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jaswine.com/interview/docs/server/nginx/</guid>
      <description> Nginx面试题 理论 使用反向代理服务器的优点是什么？
- 隐藏真正的服务器，安全  原理 Nginx是怎么处理HTTP请求的？
- Nginx使用反应器模式  Nginx负载均衡算法是怎么实现的？
- 轮询 - 权重 - 对ip进行hash取模  应用 </description>
    </item>
    
    <item>
      <title>Nginx</title>
      <link>https://jaswine.com/interview/docs/server/tomcat/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jaswine.com/interview/docs/server/tomcat/</guid>
      <description> Nginx面试题 理论 使用反向代理服务器的优点是什么？
- 隐藏真正的服务器，安全  原理 Nginx是怎么处理HTTP请求的？
- Nginx使用反应器模式  Nginx负载均衡算法是怎么实现的？
- 轮询 - 权重 - 对ip进行hash取模  应用 </description>
    </item>
    
    <item>
      <title>分布式系统</title>
      <link>https://jaswine.com/interview/docs/arch/distributed/</link>
      <pubDate>Sat, 04 May 2019 10:44:39 +0800</pubDate>
      
      <guid>https://jaswine.com/interview/docs/arch/distributed/</guid>
      <description>分布式面试题 基础 说说你对分布式一致性和CAP,BASE一致性协议的理解
分布式数据库 分布式集群下怎么做到唯一序列号
分布式锁有哪些实现方式？(3)
分布式事务的原理，优缺点，如何使用分布式事务，2pc，3pc的区别，解决了哪些问题</description>
    </item>
    
    <item>
      <title>Zookeeper</title>
      <link>https://jaswine.com/interview/docs/arch/zookeeper/</link>
      <pubDate>Sat, 04 May 2019 10:41:12 +0800</pubDate>
      
      <guid>https://jaswine.com/interview/docs/arch/zookeeper/</guid>
      <description> ZooKeeper面试题 基础 如何使用zookeeper实现分布式锁？有什么区别优缺点，会有什么问题，分别适用什么场景(可以说说redlock的算法实现) 什么是paxos算法，什么是zab协议 </description>
    </item>
    
    <item>
      <title>消息队列</title>
      <link>https://jaswine.com/interview/docs/message/kafka/</link>
      <pubDate>Sat, 04 May 2019 10:32:02 +0800</pubDate>
      
      <guid>https://jaswine.com/interview/docs/message/kafka/</guid>
      <description> 消息队列面试题 基础 为什么使用消息队列，优缺点是什么是呢？
你们在工作中是这么对消息队列进行选型的
消息队列的高可用你们是这么实现的
如何保证消息不被重复消费的
消息传输的可靠性你们是这么做到的？
你们是这么保证消息的顺序性的？
ActiveMQ RabbitMQ </description>
    </item>
    
    <item>
      <title>消息队列</title>
      <link>https://jaswine.com/interview/docs/message/pulsar/</link>
      <pubDate>Sat, 04 May 2019 10:32:02 +0800</pubDate>
      
      <guid>https://jaswine.com/interview/docs/message/pulsar/</guid>
      <description> 消息队列面试题 基础 为什么使用消息队列，优缺点是什么是呢？
你们在工作中是这么对消息队列进行选型的
消息队列的高可用你们是这么实现的
如何保证消息不被重复消费的
消息传输的可靠性你们是这么做到的？
你们是这么保证消息的顺序性的？
ActiveMQ RabbitMQ </description>
    </item>
    
    <item>
      <title>消息队列</title>
      <link>https://jaswine.com/interview/docs/message/rabbit/</link>
      <pubDate>Sat, 04 May 2019 10:32:02 +0800</pubDate>
      
      <guid>https://jaswine.com/interview/docs/message/rabbit/</guid>
      <description> 消息队列面试题 基础 为什么使用消息队列，优缺点是什么是呢？
你们在工作中是这么对消息队列进行选型的
消息队列的高可用你们是这么实现的
如何保证消息不被重复消费的
消息传输的可靠性你们是这么做到的？
你们是这么保证消息的顺序性的？
ActiveMQ RabbitMQ </description>
    </item>
    
    <item>
      <title>数据库</title>
      <link>https://jaswine.com/interview/docs/data/mysql/</link>
      <pubDate>Mon, 29 Apr 2019 09:51:30 +0800</pubDate>
      
      <guid>https://jaswine.com/interview/docs/data/mysql/</guid>
      <description>数据库面试题(默认MySQL) SQL 说说你对存储过程的理解，为什么阿里的编程规范中禁用存储过程，他有什么优缺点
# 理解 - 存储过程就是一些SQL组成的代码块，可以重复使用 # 为什么禁用存储过程  说说你对SQL的连接查询(Join)的理解，他们之间的区别是什么
# inner join - 两个表交集的部分 # full out join - 两个表并集，没有匹配的为null # left join - 以左表为主，没有匹配的为null # right join - 以右表为主，没有匹配的为null  数据库 索引 说说你对数据库索引的理解，你在项目开发中是如何使用索引的，使用索引一定可以提高查询的性能吗？
# 索引理解 - MySQL索引的本质是B+树 # 如何使用 - 不同索引类型添加方式不一样，不过都是雷同的 alter table [table_name] add [index_type] [index_name] [字段名] # 不能，要正确的建立索引 # Tips：索引建立的几大原则 - 最左前缀匹配原则，MySQL一直向右匹配知道遇到查询范围(&amp;gt;,&amp;lt;,between,like)停止匹配 - in和=可以乱序 - 选择区分度比较高的列作为索引 - 索引列不参加计算 - 尽量扩展索引，不新建索引  说说数据库的索引都有哪些类型 |索引名|特点| |:&amp;ndash;|:&amp;ndash;| |UNIQUE(唯一索引)|不可以出现相同的值，可以有null| |INDEX(普通索引)|允许出现相同的索引内容| |PROMARY KEY(主键索引)|不允许出现相同的值| |FULLTEXT INDEX(全文索引)|对全文进行索引，效率很差| |组合索引|实质上是将多个字段建到一个索引里，列值的组合必须唯一|</description>
    </item>
    
    <item>
      <title>架构</title>
      <link>https://jaswine.com/interview/docs/arch/arch/</link>
      <pubDate>Mon, 29 Apr 2019 09:50:32 +0800</pubDate>
      
      <guid>https://jaswine.com/interview/docs/arch/arch/</guid>
      <description> 架构设计面试题 高并发 高可用 可伸缩 安全性 如果有人恶意创建非法链接，怎么解决
扩展性 敏捷性 综合 设计一个秒杀系统，30分钟没付款就自动关闭交易 如何设计建立和保持100W的长连接 一个在线文档，文档可以被编辑，如何方式多人同时对一份文档和进行编辑更新 </description>
    </item>
    
    <item>
      <title>Springcloud</title>
      <link>https://jaswine.com/interview/docs/spring/springcloud/</link>
      <pubDate>Mon, 29 Apr 2019 09:34:26 +0800</pubDate>
      
      <guid>https://jaswine.com/interview/docs/spring/springcloud/</guid>
      <description> SpringCloud面试题 SpringCloud基础 SpringCloud和Dubbo相比的一些优缺点是什么？     优点 缺点     dubbo     cloud      服务注册和发现 Eureka 服务发现组件Eureka工作原理 服务调用 什么是Netflix？他的优点是什么？ 服务容错 什么是Hystrix？他是怎么实现容错机制的 服务网关 zuul zuul的工作原理 </description>
    </item>
    
    <item>
      <title>Springboot</title>
      <link>https://jaswine.com/interview/docs/spring/springboot/</link>
      <pubDate>Mon, 29 Apr 2019 09:34:17 +0800</pubDate>
      
      <guid>https://jaswine.com/interview/docs/spring/springboot/</guid>
      <description> SpringBoot面试题 SpringBoot基础 SpringBoot和Spring之间的区别是什么 - Spring是Spring boot的基石 - Spring boot在Spring的基础上实现了自动化配置和起步依赖等相关特性  SpringBoot有什么优点，都是怎么实现这些优点的。 SpringBoot启动执行过程是什么样子的 - 看@SpringBootApplication注解就是@SpringBootConfiguration、@EnableAutoConfiguration和@ComponentScan的组合 -- @SpringBootConfiguration开启JavaConfig的方式 -- @EnableAutoConfiguration开启自动化注解 -- @ComponentScan扫描classpath下的bean - run方法中构造一个SpringApplication实例 - 构造实例过程中调用initialize方法初始化，主要给springApplication对象赋一些初始值 -  怎么在SringBoot启动时运行一些特定的代码 - 实现CommandLineRunner接口 - 重写run方法  SpringBoot起步依赖 SpringBoot是怎么实现起步依赖的 在pom.xml中引入的各种starter是一个pom打包形式的工程，我们引入后根据Maven的依赖传递来导入相关的包  什么是SpringBoot Starter - 实现了起步依赖，starter中定义了相关的依赖  SpringBoot自动配置 说说你对SpringBoot自动配置的理解 - 使用@EnableAutoConfiguration注解开启自动注解 - 使用@condition注解来完成条件化配置  SpringBoot配置加载的顺序是什么？ properties &amp;gt; YAML &amp;gt; JavaConfig &amp;gt; 命令行参数  SpringBoot有哪几种方式读取配置 - @value，读取xxx.properties和xxx.yaml中的配置信息 - @PropertySource - @Environment - @ConfigurationProperties  SpringBoot命令行 Actuator </description>
    </item>
    
    <item>
      <title>缓存</title>
      <link>https://jaswine.com/interview/docs/arch/cache/</link>
      <pubDate>Mon, 29 Apr 2019 09:34:04 +0800</pubDate>
      
      <guid>https://jaswine.com/interview/docs/arch/cache/</guid>
      <description> 缓存面试题 如何防止缓存击穿和雪崩 </description>
    </item>
    
    <item>
      <title>搜索引擎</title>
      <link>https://jaswine.com/interview/docs/search/search/</link>
      <pubDate>Mon, 29 Apr 2019 09:33:55 +0800</pubDate>
      
      <guid>https://jaswine.com/interview/docs/search/search/</guid>
      <description> 搜索引擎面试题 Elasticsearch 说说你们公司使用的es集群架构，索引数据大小，分片有多少，怎么调优的 es的倒排索引是什么？ es是怎么实现master选举的 </description>
    </item>
    
    <item>
      <title>Mybatis</title>
      <link>https://jaswine.com/interview/docs/java/mybatis/</link>
      <pubDate>Mon, 29 Apr 2019 09:33:46 +0800</pubDate>
      
      <guid>https://jaswine.com/interview/docs/java/mybatis/</guid>
      <description> Mybatis面试题 应用 Mybatis中#{}和${}区别 |#|$| |:&amp;ndash;|:&amp;ndash;| |预编译|直接传入值| |可以防止SQL注入|不能防止SQL注入| |不能放在order by后面|可以放在order by后面|
Mybatis传入多个参数
- #{0},#{1} - @param注解  Mybatis分页查询的原理
- 使用pagehelp做分页查询 - 本质上就是对sql进行拦截然后重写  原理 Mybatis定义的接口是怎么找到实现的
使用动态代理技术  </description>
    </item>
    
    <item>
      <title>Netty</title>
      <link>https://jaswine.com/interview/docs/java/netty/</link>
      <pubDate>Mon, 29 Apr 2019 09:33:39 +0800</pubDate>
      
      <guid>https://jaswine.com/interview/docs/java/netty/</guid>
      <description>Netty面试题 原理 为什么选择Netty
Netty是怎么实现异步非阻塞的IO的
Netty的线程模型是什么？如何基于Reactor模型上实现的
Netty中fashwheeltimer的用法，实现原理，是否出现过调用不够准时，怎么解决这个问题
Netty的通讯协议是什么样的
应用 Netty的心跳处理在弱网下怎么办？
为什么选择Netty</description>
    </item>
    
    <item>
      <title>设计模式</title>
      <link>https://jaswine.com/interview/docs/model/model/</link>
      <pubDate>Mon, 29 Apr 2019 09:33:29 +0800</pubDate>
      
      <guid>https://jaswine.com/interview/docs/model/model/</guid>
      <description> 设计模式面试题 创建型 工厂模式 建造者模式 单例模式 写出三种单例模式实现 结构型 适配器模式 桥接模式 装饰者模式 外观模式 享元模式 代理模式 行为型 命令模式 中介者模式 观察者模式 状态模式 策略模式 MVC 说说你对MVC模式的理解，你用过什么MVC框架 </description>
    </item>
    
    <item>
      <title>JavaWeb</title>
      <link>https://jaswine.com/interview/docs/java/jwb/</link>
      <pubDate>Mon, 29 Apr 2019 09:32:24 +0800</pubDate>
      
      <guid>https://jaswine.com/interview/docs/java/jwb/</guid>
      <description> JavaWeb开发面试题 浏览器 怎么避免浏览器缓存 Servlet session和cookie的区别和联系，session的生命周期是什么样的？集群环境下怎么管理session - session是又服务端维护的，记录用户的相关信息 - cookie是服务端生成，客户端维护的，大小不能超过4KB  Servlet容器 讲讲Tomcat的结构，以及其类加载器流程，线程模型 怎么对Tomcat进行调优，涉及到什么参数呢？ </description>
    </item>
    
    <item>
      <title>算法</title>
      <link>https://jaswine.com/interview/docs/base/algo/</link>
      <pubDate>Mon, 29 Apr 2019 09:32:16 +0800</pubDate>
      
      <guid>https://jaswine.com/interview/docs/base/algo/</guid>
      <description>算法面试题 基础算法 hash算法 说说你知道的几种hash算法
在10亿个数字中找到最小的10个
有一亿个其中有两个是重复的，快速找到它，要求空间和时间最优
2亿个随机生成的无序整数中找出中间大小的值</description>
    </item>
    
    <item>
      <title>数据结构</title>
      <link>https://jaswine.com/interview/docs/base/ds/</link>
      <pubDate>Mon, 29 Apr 2019 09:32:07 +0800</pubDate>
      
      <guid>https://jaswine.com/interview/docs/base/ds/</guid>
      <description> 数据结构 数组 数组动态扩容是怎么实现的
- 新建一个空数组(比原来的大) - 将原数组的元素拷贝到新数组中  链表 怎么使用链表实现LRU呢？
- 1.当链表为空的时候 - 1.1.当前id为head - 2.链表不为空的时候 - 2.1.搜索插叙的id - 2.1.1.链表中有该id，将该id为head - 2.1.2.链表中没有该id - 2.1.2.1.链表满了，删除tail元素，id放在head - 2.1.2.2.链表未满，id放在head  栈 队列 散列表(hash表) 解决hash冲突都有什么办法？并简单说下实现原理是什么样的？之间的区别是什么？
# 开放寻址法 - 计算出对应的散列值之后如果冲突了就向下继续寻找到空位，如果没有就从表的头开始寻找 # 链表法 - hash表中存放的元素就是一个链表，当hash值相同的时候就插入到链表的对应位置上 # 区别 - 数据量小，装载因子小的时候选择开放寻址法 - 大数据量，大对象的散列表选择链表法，更加的灵活，可以使用红黑树来替代链表  树 图 </description>
    </item>
    
    <item>
      <title>计算机网络</title>
      <link>https://jaswine.com/interview/docs/base/net/</link>
      <pubDate>Mon, 29 Apr 2019 09:31:47 +0800</pubDate>
      
      <guid>https://jaswine.com/interview/docs/base/net/</guid>
      <description>计算机网络 HTTP协议 说说你知道的HTTP响应码
- 1xx  怎么理解HTTP协议的无连接和无状态性
# 无连接 客户端和服务端完成一次交互后就断开连接 # 无状态 服务端不会记录客户端的信息，不知道客户端是谁 Tips： - 无连接使用keep-alive解决，现在的http服务器支持keep-alive - 无状态使用cookies-session来解决了  HTTP中GET和POST的区别和数据包格式
# 从设计角度来说 - GET请求是幂等的，请求前后不会对数据造成变化 - POST是向服务端提交数据，提交数据就是为了修改相关数据，所以不是幂等的 # 从应用角度来说 - GET的请求有长度限制，URL最大长度为2048byte - POST请求没有长度限制 # 从浏览器角度来说 - GET请求回退和刷新不会产生危害 - POST会重新提交请求 - GET可以被缓存 - POST不能被缓存  简单说下HTTP报文的格式 HTTP长连接是什么？
前提：HTTP长连接本质上是TCP的长连接 HTTP1.0默认短链接 HTTP1.1默认长连接  HTTPS加密方式是什么？讲讲整个加密和解密的流程
HTTP和HTTPS三次握手有什么区别
TCP协议 TCP三次握手和四次握手的流程，为什么断开连接要四次，如果握手只有两次会出现什么
# 三次握手 - 1.客户端发送SYN=1的包和seq=x的版本好信息，进入SYN_SEND状态 - 2.服务端发回确认包SYN=1，ACK=1，将自己的ISN序列号放到seq=y中，同时发送ACKnum=x+1，服务端进入SYN_RCVD状态 - 3.客户端收到包，SYN=0，ACK=1，ACKnum=y+1，客户端进入到ESTABLISHED阶段 # 四次挥手 - 1.客户端发送FIN=1，seq=x数据到服务端，进入FIN_WAIT_1状态 - 2.服务端收到包，发送ACK=1，ACKnum=x+1，服务端进入CLOSE_WAIT状态，客户端接收到包进入到FIN_WAIT_2状态 - 3.服务端发送FIN=1，seq=y给客户端，进入到LAST_ACK，等待客户端的ACK - 4.</description>
    </item>
    
    <item>
      <title>操作系统</title>
      <link>https://jaswine.com/interview/docs/base/os/</link>
      <pubDate>Mon, 29 Apr 2019 09:31:37 +0800</pubDate>
      
      <guid>https://jaswine.com/interview/docs/base/os/</guid>
      <description>计算机操作系统 进程 文件 I/O 操作系统的io模型是什么？</description>
    </item>
    
    <item>
      <title></title>
      <link>https://jaswine.com/interview/docs/data/ShardingSphere/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jaswine.com/interview/docs/data/ShardingSphere/</guid>
      <description> ShardingSphere分库分表 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://jaswine.com/interview/docs/data/mycat/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jaswine.com/interview/docs/data/mycat/</guid>
      <description> Mycat分表分库 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://jaswine.com/interview/docs/data/redis/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jaswine.com/interview/docs/data/redis/</guid>
      <description> Redis Redis中list结构相关的操作
说说你在项目中使用Redis集群的用法
Redis怎么存放热点数据？时长怎么控制的？原理呢？
  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://jaswine.com/interview/docs/data/sql/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jaswine.com/interview/docs/data/sql/</guid>
      <description> SQL 说说你对存储过程的理解，为什么阿里的编程规范中禁用存储过程，他有什么优缺点
# 理解 - 存储过程就是一些SQL组成的代码块，可以重复使用 # 为什么禁用存储过程  说说你对SQL的连接查询(Join)的理解，他们之间的区别是什么
# inner join - 两个表交集的部分 # full out join - 两个表并集，没有匹配的为null # left join - 以左表为主，没有匹配的为null # right join - 以右表为主，没有匹配的为null  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://jaswine.com/interview/docs/java/se/adventage/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jaswine.com/interview/docs/java/se/adventage/</guid>
      <description> Java高级特性 Java注解，泛型，枚举 JDK1.5引入了泛型，泛型的存在是用来解决什么问题
Java高级特性 反射的原理是什么？反射创建类实例的三种方式是什么？
 动态代理有哪些实现方式，你知道他们相应的优缺点吗？
# 实现方式 - JDK动态代理 - cglib动态代理 # 优缺点 如下      JDK cglib     区别 只能对实现同一接口的类进行代理 可以对任何类惊醒代理，但是不能对final修饰的类进行代理   原理 使用Java反射原理实现的 使用asm的开源工具将代理的类加载进来实现其子类，然后重写相关的方法    </description>
    </item>
    
    <item>
      <title></title>
      <link>https://jaswine.com/interview/docs/java/se/base/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jaswine.com/interview/docs/java/se/base/</guid>
      <description>Java基础知识 Java版本特性 说说每个版本Java的新特性
# 1.5 - 自动装箱和拆箱 - 新增枚举类型 - 新增注解类型 - 泛型的支持 - 静态导入的支持 - For-Each循环支持 - 可变参数 # 1.6 - 轻量级HTTP SERVER API # 1.7 - Java集合的增强，可以直接使用[]，{}来存入对象 - Switch中可以使用String(以前只可以使用基本类型变量) # 1.8 - 接口方法中可以默认实现(使用default关键字) - Lambda表达式的支持 - 函数式的接口(使用@Functionallnterface) - 使用::关键字来传递方法或者构造函数引用 - 多重注解 - 集合类的增强 - Stream流式计算  Java中try&amp;hellip;catch&amp;hellip;finally&amp;hellip;return执行的先后顺序
- 先执行try中的代码，遇到try中的return执行但是不返回到main方法中  Java关键字 final有什么用途？
- final表示不变，可以修饰变量，方法和类 -- 修饰变量的时候这个变量一旦被初始化完成就不会被改变 -- 修饰方法说明在这个方法不能被修改 -- 修饰类说明这个类不能被继承 - final一般也是一种多线程的设计模式，因为对象不变就不存在多线程并发安全的问题了  static关键字这么用
- static修饰方法：不需要依靠实例对象来访问 - static修饰变量：类对象，在类加载的时候就有了 - static修饰代码块：在类加载的时候就初始化，只初始化一次 - static修饰内部类：就是一个内部类 - static静态导包  逻辑运算 a=a+b和a+=b之间的区别是什么？</description>
    </item>
    
    <item>
      <title></title>
      <link>https://jaswine.com/interview/docs/java/se/collection/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jaswine.com/interview/docs/java/se/collection/</guid>
      <description>Java集合 List系 ArrayList、LinkedList和Vector之间的区别，他们线程安全吗？不安全怎么解决
 🔗链接ArrayList为什么线程不安全及解决办法 🔗连接LinkedList为什么线程不安全及解决办法     名称 数据结构 是否线程安全 原理 线程安全方法     ArrayList Object数组 不安全 / 1.使用Collections.synchronizedList(List)包装
2.使用CopyOnWriteArrayList   LinkedList 双向链表 不安全 / 1.使用Collections.synchronizedList(List)包装
   Vector Object数组 安全 (同步方法)synchronized /    ArrayList是如何实现动态扩容的
 🔗链接源码分析-Java中ArrayList是如何实现数组动态扩容的
- ArrayList的本质是Object[]，所以他本质上就是数组的动态扩容 - Java底层的数组扩容就是通过数组拷贝完成的   Map系 Map接口的实现类，简单的说说他们
   类 底层数据结构 特点 是否线程安全     HashMap 数组+链表/红黑树 可以使用null作为Key和Value 不安全   Hashtable 数组+链表/红黑树 非null的key和value 安全   LinkedHashMap 继承HashMap，多维护一个双向链表 同HashMap，有序的 不安全   TreeMap 红黑树 有序 不安全   Properties 继承hashtable  安全    Map接口实现类之间的区别</description>
    </item>
    
    <item>
      <title></title>
      <link>https://jaswine.com/interview/docs/java/se/concurrent/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jaswine.com/interview/docs/java/se/concurrent/</guid>
      <description>Java多线程/并发编程 Java多线程基础理论 什么是线程安全？线程不安全的根源是什么？Java是怎么解决的
# 线程安全 - 一个方法或者实例在多线程环境下使用不会出现问题，这个问题本质上就是共有数据在被并发修改的产生脏写的问题   不安全的根源
 线程并发原子性 线程并发可见性 线程并发有序性  Java的解决办法
 Java使用JMM保证了多线程并发的情况下线程之间的有序性和可见性 使用锁来解决原子性问题   说说死锁
# 死锁发生的条件 - 互斥，共享资源x、y只能被一个线程占有 - 占有等待，线程T1占有资源x还在等待资源y - 不可抢占，其他线程不能抢占T1的资源 - 循环等待，T1和T2互相等待对方释放资源 # 解决死锁 - 一次申请所有锁资源，申请不到就不占有 - 如果申请不到锁资源，主动释放自己身上的锁资源 -  画一下线程生命周期和状态转换图
一个线程两次调用start()方法会怎么样
 会抛出IllegalThreadStateException错误  你知道停止一个线程有哪些方法，他们之间都有什么区别
# 方法 - Thread.stop() - Thread.interrupt() - run方法结束(正常停止线程) # 区别 - stop()在JDK中已经被遗弃，执行stop方法后会立即终止线程，释放当前线程持有锁资源，破坏了对象的一致性 - interrupt()执行后不会立马终止线程，会设置一个中断标记位  sleep()和wait()的区别
   wait sleep     Object的方法 Thread的方法   执行的时候释放锁 执行的时候不释放锁   只能在同步方法和同步块中使用 可以在任何地方使用   无需捕捉异常 需要捕捉异常    讲讲Java同步机制的wait和notify</description>
    </item>
    
    <item>
      <title></title>
      <link>https://jaswine.com/interview/docs/java/se/exception/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jaswine.com/interview/docs/java/se/exception/</guid>
      <description>#Java异常
Error和Exception的区别，CheckedException和RuntimeException
说说你知道的运行时异常</description>
    </item>
    
    <item>
      <title></title>
      <link>https://jaswine.com/interview/docs/java/se/io/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jaswine.com/interview/docs/java/se/io/</guid>
      <description> Java I/O 基础 IO模型有哪些？在Java中对应的实现是什么
# IO模型 - 同步阻塞IO模型(BIO) - 同步非阻塞IO模型(NIO) - IO多路复用 - 信号驱动IO - 异步IO(AIO,NIO2) Tips：这些都是操作系统中相关的概念 # Java中的对应实现 - 同步阻塞IO就是传统的IO，或者叫BIO，简化的来理解就是所有的操作都在一个线程中完成 - 非阻塞IO在Java中的实现是NIO，使用selector,channel和Buffer来实现，底层其实使用的是操作系统中的epoll实现的 - 异步IO叫做NIO2或者AIO，是异步非阻塞的，基于事件和回调机制来实现  NIO 你对NIO是怎么理解的，Java中的NIO是怎么实现的？NIO和AIO,BIO的区别是什么？
# NIO - 使用缓冲区和通道的概念来实现处理数据 - NIO中通道是双向的 - 缓冲区可以分片 # 实现 - 客户端将流写到缓冲区 - 使用channel将数据从buffer转移 # NIO和AIO,BIO的区别 - AIO是异步非阻塞的，BIO是同步阻塞的，NIO是同步非阻塞的 - AIO也可以叫做NIO2 # Tips - JDK1.7中NIO中新增了4个异步通道  NIO2/AIO </description>
    </item>
    
    <item>
      <title></title>
      <link>https://jaswine.com/interview/docs/java/se/menu/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jaswine.com/interview/docs/java/se/menu/</guid>
      <description> Java知识分类  基础 面向对象思想 I/O 集合 多线程/并发 异常 高级特性  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://jaswine.com/interview/docs/java/se/oo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jaswine.com/interview/docs/java/se/oo/</guid>
      <description> Java面向对象 怎么理解继承和聚合的概念，他们之间有什么异同
# 继承 - 继承是子类继承父类，可以对父类的内容进行扩展和修改 # 聚合 - 聚合是模块和模块之间的关系，是可以分离的，有自己的生命周期  结合OO设计理念，谈谈访问修饰符public，default，protected和private在应用中设计的作用
    同类 同包 子类 非同包类     public Y Y Y Y   protected Y Y Y X   default Y Y X X   private Y X X X    Java抽象类和接口的异同，说说为什么Java这么设计
    接口 抽象类     变量     方法 全是抽象方法 可以不全是抽象方法     设计原因  避免了多继承 接口和继承存在的意义不同   </description>
    </item>
    
    <item>
      <title></title>
      <link>https://jaswine.com/interview/docs/java/vm/classload/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jaswine.com/interview/docs/java/vm/classload/</guid>
      <description> 类加载 类加载的步骤是什么
加载--&amp;gt;验证--&amp;gt;准备--&amp;gt;解析--&amp;gt;初始化--&amp;gt;使用--&amp;gt;卸载  Class.forName()和classloader的区别
- Class.forName()将class文件加载到虚拟机中到初始化的工作 - classloader只是将class文件加载到jvm中  说说你了解的类加载器，以及他们工作的原理
# 类加载器 - 启动类加载器(Bootstrap ClassLoader) - 扩展类加载器(ExtClassLoader) - 应用类家再起(AppClassLoader) # 原理  可以打破双亲委派吗？是怎么打破的？
# 可以打破双亲委派双亲委派 - SPI就是打破双亲委派 # 怎么打破  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://jaswine.com/interview/docs/java/vm/concurrent/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jaswine.com/interview/docs/java/vm/concurrent/</guid>
      <description> 高并发 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://jaswine.com/interview/docs/java/vm/gc/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jaswine.com/interview/docs/java/vm/gc/</guid>
      <description>垃圾回收(GC) 说说你知道的GC算法和对应的原理是什么？都有缺点
   算法 原理 缺点     标记-清除 先对对象进行标记然后回收 内存碎片太多   标记-复制-清除 将存活的对象复制到一块空内存上，然后清除原来的内存 空间浪费   标记-压缩-清除 将存活的对象移动到一个地方，然后指针之后的全部删除    分代收集 对对象进行分代然后不同的代使用不同的回收算法     JVM中一次完整的GC流程是怎么样的，对象如何晋升到老年代
# 流程 1.触发GC - 内存不够使用 - 主动触发GC，System.gc() 2.标记 - 找出所有对象的 3.复制 | 压缩 - 复制算法就是将存活的对象复制到一个空的内存块 - 压缩(整理)算法计算出存活对象的新地址然后移动对象的地方 3.清理 - 将之前标记的dead的对象回收了 # 如何晋升老年代 - 大对象直接进入老年代 - 几次Minor GC还存活的对象  说说你对Minor GC和Full GC的理解
Minor GC
 定义：新生代(包括Eden和Survivor)垃圾搜集叫做 Minor GC 触发条件：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://jaswine.com/interview/docs/java/vm/jmm/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jaswine.com/interview/docs/java/vm/jmm/</guid>
      <description>Java虚拟机内存模型 内存模型和分代 简单说说JVM中内存的分配情况吧
Java8之前： # 线程私有 - 程序计数器(当前线程执行字节码的行号指示器) - 虚拟机栈(局部变量，方法信息) - 本地方法栈(JNI方法) # 线程共有 - 堆内存(对象存放的地方) - 方法区(已被虚拟机加载的类信息，常量，静态变量) -- 运行时常量池(方法区的一部分) # 特别 - 直接内存(非JVM内存规范中的一部分)  OOM和排查 什么时候会发生内存溢出(OOM)？
# 程序计数器 - 不会发生OOM错误 # 虚拟机栈 &amp;amp; 本地方法栈 - 虚拟机扩展栈的时候无法获取到足够的空间就会抛出OOM的错误 # 堆内存 - 对象数量达到堆内存的最大值的时候出现OOM错误 # 方法区 &amp;amp; 运行时常量池 - 产生大量的类信息大于了方法区的最大值  Java内存为什么分成新生代，老年代，持久代？是怎么划分的呢？怎么回收的呢？新生代中为什么要分为Eden和Survivor
# 为什么分代 - 为了优化GC性能(Java中每个对象的生命周期不一样，所以不同对象要分类以便更好的回收) # 怎么划分 - 新生代(Young Generation) - 分成三个部分：Eden，From Survivor ，To Survivor，比例是8:1:1 - 保持一个Survivor为空 - 年老代(Tenured Generation) - 多次GC都没有被GC的会进入年老带 - 新生代没有空间了会直接进入年老代 - 永久代(Permanent Generation) - 对应运行时内存的“方法区”，一般不会被GC，JVM退出才销毁 # 怎么回收 - 新生代 - 因为生命周期很短，GC吞吐量很高，适合使用复制算法来GC，这样保证来复制的数据量最小 - 年老代 - 因为对象的存活时间很长，所以要移动大量的对象，效率很低，所以年老代适合使用标记-清除算法 # 为什么分为Eden和Survivor  你对JVM内存中重排序，内存屏障，happen-before，主内存，工作内存是怎么理解的</description>
    </item>
    
    <item>
      <title></title>
      <link>https://jaswine.com/interview/docs/java/vm/menu/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jaswine.com/interview/docs/java/vm/menu/</guid>
      <description> JVM知识分类  Java内存模型 类加载 对象解析 垃圾回收(GC) JVM参数 高并发 实例  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://jaswine.com/interview/docs/java/vm/object/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jaswine.com/interview/docs/java/vm/object/</guid>
      <description> 对象解析 说说你对Java对象组成的理解
- Java对象内部由三个部分组成:对象头，实例数据，对齐填充字节 # 对象头 - 对象头包括如下部分: -- MarkWord:记录了对象的锁，GC等等的信息 -- 指向类的指针 -- 数组的长度(数组对象才有) # 实例数据 - 实例数据就是我们在代码中看到的属性和值 # 填充字节 - 对齐填充字节:因为JVM中对象的是8bit的整数倍，所有要有相关的字节来填充  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://jaswine.com/interview/docs/java/vm/params/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jaswine.com/interview/docs/java/vm/params/</guid>
      <description>Jvm参数 说说你知道的JVM参数</description>
    </item>
    
    <item>
      <title></title>
      <link>https://jaswine.com/interview/docs/java/vm/tools/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jaswine.com/interview/docs/java/vm/tools/</guid>
      <description> 实例 如何Java内存泄漏的问题进行调查和定位
 使用jps -l 查询所有的JVM进程 使用jstat &amp;lt;对应进程id&amp;gt;监控当前进程的情况 使用jmap来看内存分布快照 把内存堆dump下来然后使用MAT来分析内存  __
# 1. # 2.使用jstat 使用jmap和jstack  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://jaswine.com/interview/docs/message/base/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jaswine.com/interview/docs/message/base/</guid>
      <description> 消息队列基础 为什么使用消息队列？优缺点？比较一下Kafka，ActiveMQ，RabbitMQ，RocketMQ # 为啥使用 - 业务需要 - 解藕 - 异步 - 削峰  消息队列优缺点:
    优点 缺点     MQ 1.解藕,异步,削峰 1.系统可用性降低(MQ挂了)
2.复杂度提高(保证消息按照想象的被消费)
3.最终一致性    不同消息队列实现的比较
   特性 ActiveMQ RabbitMQ RocketMQ Kafka     单机吞吐量 万级 万级 10万级 10万级    </description>
    </item>
    
    <item>
      <title></title>
      <link>https://jaswine.com/interview/docs/search/elasticsearch/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jaswine.com/interview/docs/search/elasticsearch/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://jaswine.com/interview/docs/search/solr/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jaswine.com/interview/docs/search/solr/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://jaswine.com/interview/docs/spring/framework/core/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jaswine.com/interview/docs/spring/framework/core/</guid>
      <description>Spring FrameWork核心 Spring容器基础 依赖注入是什么意思？有哪些方式呢？
# 依赖注入 - 完成一件事要多个配合，通常和自己没有关系 # 方式 - 构造器注入 - set注入 - 静态工厂 - 实例工厂  Spring容器&amp;amp;Bean Spring中IOC是怎么实现的，IOC容器初始化的过程是什么样子的
# 初始化过程 -1.Resource定位： -2.载入：使用BeanDefinition来解析bean定义 -3.注册：使用BeanDefinitionRegistery来将定义好的bean注册到IOC容器中  Spring的加载流程是什么
# 主要类 Spring加载中有以下几个重要的类： - BeanFactory：生产Bean - Resource：Bean配置文件 - BeanDefinition：Bean定义 # 流程 - 资源定位：找到配置文件 - BeanDefinition载入和解析 -- 找到配置文件Resource -- 将配置文件解析成BeanDefinition - BeanDefinition注册 -- 将BeanDefinition向Map中注册Map&amp;lt;name,BeanDefinition&amp;gt; - bean的实例化和依赖注入 -- 通过反射或者cglib来创造bean # Tips: - Resource本质上就是字节流 - BeanDefinition是bean的详细信息  说说BeanFactory和ApplicationContext有什么区别
   类目 BeanFactory ApplicationContext      启动时不实例化Bean 启动时就将Bean进行实例化    Tips： - ApplicationContext实现了BeanFActory，所以ApplicationContext有BeanFactory的所有功能</description>
    </item>
    
    <item>
      <title></title>
      <link>https://jaswine.com/interview/docs/spring/framework/data/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jaswine.com/interview/docs/spring/framework/data/</guid>
      <description>SpringData Spring事务 Spring是怎么配置事务和管理事务的
# 怎么管理事务的 - Spring事务管理使用TransactionDefinition，TransactionStatus和PlatformTransactionManager来完成事务的管理工作。 # XML配置方式  Spring的事务隔离级别
 讲讲Spring事务的传播属性
讲讲Spring事务失效的情况
spring RestTemplate的具体实现</description>
    </item>
    
    <item>
      <title></title>
      <link>https://jaswine.com/interview/docs/spring/framework/menu/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jaswine.com/interview/docs/spring/framework/menu/</guid>
      <description> Spring FrameWork 知识点  Spring FrameWork核心 Spring Web Spring Data Spring 设计模式  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://jaswine.com/interview/docs/spring/framework/model/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jaswine.com/interview/docs/spring/framework/model/</guid>
      <description> Spring中的设计模式 单例模式 Spring的单例实现原理
- 使用单例注册表的方式来管理bean --  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://jaswine.com/interview/docs/spring/framework/web/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jaswine.com/interview/docs/spring/framework/web/</guid>
      <description> Spring Web SpringMVC SpringMVC的运行原理和启动流程是什么样子的
# 启动流程 # 运行原理 - 请求到达DispatchServlet，根据请求的相关信息到HandlerMapping中查找到具体的Handler(Controller) - Controller调用具体的业务逻辑后将结果返给DispatcherServlet，最后返给客户端  DispatchServlet初始化过程
 说说你在SpringMVC用到的注解，作用是什么
SpringMVC中的Controller是单例还是多例，怎么保证并发的安全
Spring WebFlow </description>
    </item>
    
  </channel>
</rss>