<!DOCTYPE html>




<html lang="en">

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>
  
    
    Java
  
 | 面试题</title>


<link href="https://fonts.googleapis.com/css?family=Oxygen|Oxygen+Mono:300,400,700" rel="stylesheet">



<link rel="stylesheet" href="/book.min.a3caa905766cf610e263c876d2f2d8477f59d64606267bcaeee26e73160f9285.css">


<link rel="icon" href="/favicon.png" type="image/x-icon">


<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->

  
</head>

<body>
  <input type="checkbox" style="display: none" id="menu-control" />
  <main class="flex container">

    <aside class="book-menu fixed">
      <nav role="navigation">
<h2 class="book-brand">
  <a href="https://interview.jaswine.com/">面试题</a>
</h2>



    

  
  





 
  
    

  <ul>
    
    
    <li>
      

  <a href="/docs/distributed/" >
    
  
    
    分布式系统
  

  </a>


    </li>
    
    <li>
      

  <a href="/docs/zookeeper/" >
    
  
    
    Zookeeper
  

  </a>


    </li>
    
    <li>
      

  <a href="/docs/message/" >
    
  
    
    消息队列
  

  </a>


    </li>
    
    <li>
      

  <a href="/docs/data/" >
    
  
    
    数据库
  

  </a>


    </li>
    
    <li>
      

  <a href="/docs/arch/" >
    
  
    
    架构
  

  </a>


    </li>
    
    <li>
      

  <a href="/docs/springcloud/" >
    
  
    
    Springcloud
  

  </a>


    </li>
    
    <li>
      

  <a href="/docs/springboot/" >
    
  
    
    Springboot
  

  </a>


    </li>
    
    <li>
      

  <a href="/docs/spring/" >
    
  
    
    Spring
  

  </a>


    </li>
    
    <li>
      

  <a href="/docs/cache/" >
    
  
    
    缓存
  

  </a>


    </li>
    
    <li>
      

  <a href="/docs/search/" >
    
  
    
    搜索引擎
  

  </a>


    </li>
    
    <li>
      

  <a href="/docs/mybatis/" >
    
  
    
    Mybatis
  

  </a>


    </li>
    
    <li>
      

  <a href="/docs/netty/" >
    
  
    
    Netty
  

  </a>


    </li>
    
    <li>
      

  <a href="/docs/model/" >
    
  
    
    设计模式
  

  </a>


    </li>
    
    <li>
      

  <a href="/docs/jwb/" >
    
  
    
    JavaWeb
  

  </a>


    </li>
    
    <li>
      

  <a href="/docs/algo/" >
    
  
    
    算法
  

  </a>


    </li>
    
    <li>
      

  <a href="/docs/ds/" >
    
  
    
    数据结构
  

  </a>


    </li>
    
    <li>
      

  <a href="/docs/net/" >
    
  
    
    计算机网络
  

  </a>


    </li>
    
    <li>
      

  <a href="/docs/os/" >
    
  
    
    操作系统
  

  </a>


    </li>
    
    <li>
      

  <a href="/docs/jvm/" >
    
  
    
    Java虚拟机
  

  </a>


    </li>
    
    <li>
      

  <a href="/docs/java/"  class="active">
    
  
    
    Java
  

  </a>


    </li>
    
  </ul>


  











</nav>



    </aside>

    <div class="book-page">
      <header class="align-center justify-between book-header">
  <label for="menu-control">
    <img src="/svg/menu.svg" alt="Menu" />
  </label>
  <strong>
  
    
    Java
  
</strong>
</header>

      
<article class="markdown">

<h1 id="java面试题">Java面试题</h1>

<h2 id="java基础">Java基础</h2>

<h3 id="java小知识点">Java小知识点</h3>

<p><font color="#9932CC" size=4>说说每个版本Java的新特性</font></p>

<pre><code># 1.5
- 自动装箱和拆箱
- 新增枚举类型
- 新增注解类型
- 泛型的支持
- 静态导入的支持
- For-Each循环支持

# 1.6

# 1.7
- Java集合的增强，可以直接使用[]，{}来存入对象
- Switch中可以使用String(以前只可以使用基本类型变量)

# 1.8
- 接口方法中可以默认实现(使用default关键字)
- Lambda表达式的支持
- 函数式的接口(使用@Functionallnterface)
- 使用::关键字来传递方法或者构造函数引用
- 多重注解
- 集合类的增强
- Stream流式计算
</code></pre>

<p><font color="#9932CC" size=4>Java中try&hellip;catch&hellip;finally&hellip;return执行的先后顺序</font></p>

<pre><code>- 先执行try中的代码，遇到try中的return执行但是不返回到main方法中
</code></pre>

<h3 id="java关键字">Java关键字</h3>

<p><font color="#9932CC" size=4>final有什么用途？</font></p>

<pre><code>- final表示不变，可以修饰变量，方法和类
-- 修饰变量的时候这个变量一旦被初始化完成就不会被改变
-- 修饰方法说明在这个方法不能被修改
-- 修饰类说明这个类不能被继承

- final一般也是一种多线程的设计模式，因为对象不变就不存在多线程并发安全的问题了
</code></pre>

<p><font color="#9932CC" size=4>讲讲类实例化的顺序</font></p>

<pre><code>父类静态代码块 &gt; 子类静态代码块 &gt; 父类代码块 &gt; 子类代码块 &gt; 父类构造函数 &gt; 子类构造函数

# Tips：
- 静态代码块执行一次
</code></pre>

<h3 id="逻辑运算">逻辑运算</h3>

<p><font color="#9932CC" size=4>a=a+b和a+=b之间的区别是什么？</font></p>

<pre><code>有：
- 不同类型在运算的时候 a=a+b这个表达式会抛异常
- a+=b的效率更加高，但是JVM也会将a=a+b变成a+=b这种方式
</code></pre>

<p><font color="#9932CC" size=4>说说Java中的位运算和逻辑运算的区别，位运行在Java中的应用</font></p>

<pre><code># 位运算和逻辑运算区别

- 位运算有  位与(&amp;)、位或(|)、位非(~)、位异或(^)、左移(&lt;&lt;)、右移(&gt;&gt;)、无符号右移)(&gt;&gt;&gt;)
- 逻辑运算有  逻辑与(&amp;&amp;)、逻辑或(||)

- 位运算是直接对二进制进行操作
- 逻辑运算存在短路现象， A &amp;&amp; B（A为false则直接false），A || B（A为true则为true）

# 位运算的应用
- 在Java很多源码中都有使用
</code></pre>

<h3 id="object">Object</h3>

<p><font color="#9932CC" size=4>如何在父类中为子类自动完成所有的hashcode和equals实现？这么做有何优劣势</font></p>

<pre><code></code></pre>

<p><font color="#9932CC" size=4>说活你对Object中hashCode()和equals()方法的理解，在什么场景下需要对这两个方法进行重写，你是这么重写的</font>
&gt; <strong>链接:</strong><a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.3.2">JavaSE 8 #Object</a></p>

<pre><code>- equals是基于值比较而不是引用(==是比较引用地址)
- hashCode()主要为HashMap，HashSet这些集合服务
</code></pre>

<p><font color="#9932CC" size=4>深拷贝和浅拷贝的区别</font></p>

<pre><code>- 对于基本类型来说，浅拷贝和深拷贝一样，都是对值进行拷贝

- 对于引用类型来说:
-- 浅拷贝:只是复制了对应的引用，对象没有被拷贝，并且这个对象的其他引用还在
-- 深拷贝:不只复制了对象的引用，对象本身也被复制了
</code></pre>

<h3 id="string">String</h3>

<p><font color="#9932CC" size=4>String,StringBuffer和StringBuilder之间的区别，StringBuffer是怎么实现线程安全的</font>
&gt; <strong>链接:</strong>
&gt; <a href="https://blog.jaswine.com/2019/03/14/java6/#more">源码分析-Java中的String，StringBuilder和StringBuffer</a></p>

<pre><code>- String、StringBuilder和StringBuffer的底层本质都是char[]
- StringBuilder和StringBuffer继承了AbstractStringBuilder，很多方法都由AbstractStringBuilder完成了
- String是final修饰的类，所以是线程安全的
- StringBuffer的方法大多数都是用synchronized修饰的，所以是线程安全的
- StringBuilder是线程不安全的

# Tips：
- Java9开始String、StringBuilder和StringBuffer的底层改成byte[](//todo 为什么)
</code></pre>

<p><font color="#9932CC" size=4>String中UTF-8编码和GBK编码有什么区别</font></p>

<h2 id="java面向对象思想">Java面向对象思想</h2>

<p><font color="#9932CC" size=4>怎么理解继承和聚合的概念，他们之间有什么异同</font></p>

<pre><code># 继承
- 继承是子类继承父类，可以对父类的内容进行扩展和修改

# 聚合
- 聚合是模块和模块之间的关系，是可以分离的，有自己的生命周期
</code></pre>

<p><font color="#9932CC" size=4>结合OO设计理念，谈谈访问修饰符public，default，protected和private在应用中设计的作用</font></p>

<pre><code>限定了Java中相关资源的访问权限
</code></pre>

<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">同类</th>
<th align="left">同包</th>
<th align="left">子类</th>
<th align="left">非同包类</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left">public</td>
<td align="left">Y</td>
<td align="left">Y</td>
<td align="left">Y</td>
<td align="left">Y</td>
</tr>

<tr>
<td align="left">protected</td>
<td align="left">Y</td>
<td align="left">Y</td>
<td align="left">Y</td>
<td align="left">X</td>
</tr>

<tr>
<td align="left">default</td>
<td align="left">Y</td>
<td align="left">Y</td>
<td align="left">X</td>
<td align="left">X</td>
</tr>

<tr>
<td align="left">private</td>
<td align="left">Y</td>
<td align="left">X</td>
<td align="left">X</td>
<td align="left">X</td>
</tr>
</tbody>
</table>

<p><font color="#9932CC" size=4>Java抽象类和接口的异同，说说为什么Java这么设计</font></p>

<pre><code># 抽象类 &amp; 接口
- 抽象类中一定有抽象方法，接口中全是抽象方法
- 抽象类是一种继承的关系，接口是一种规范

# 设计原因
- 避免了多继承
- 接口和继承存在的意义不同
</code></pre>

<h2 id="java-i-o">Java I/O</h2>

<p><font color="#9932CC" size=4>IO模型有哪些？在Java中对应的实现是什么</font></p>

<pre><code># IO模型
- 同步阻塞IO模型(BIO)
- 同步非阻塞IO模型(NIO)
- IO多路复用
- 信号驱动IO
- 异步IO(AIO,NIO2)

Tips：这些都是操作系统中相关的概念

# Java中的对应实现
- 同步阻塞IO就是传统的IO，或者叫BIO，简化的来理解就是所有的操作都在一个线程中完成
- 非阻塞IO在Java中的实现是NIO，使用selector,channel和Buffer来实现，底层其实使用的是操作系统中的epoll实现的
- 异步IO叫做NIO2或者AIO，是异步非阻塞的，基于事件和回调机制来实现
</code></pre>

<p><font color="#9932CC" size=4>你对NIO是怎么理解的，Java中的NIO是怎么实现的？NIO和AIO,BIO的区别是什么？</font></p>

<pre><code># NIO
- 使用缓冲区和通道的概念来实现处理数据
- NIO中通道是双向的
- 缓冲区可以分片

# 实现
- 客户端将流写到缓冲区
- 使用channel将数据从buffer转移

# NIO和AIO,BIO的区别
- AIO是异步非阻塞的，BIO是同步阻塞的，NIO是同步非阻塞的
- AIO也可以叫做NIO2

# Tips
- JDK1.7中NIO中新增了4个异步通道
</code></pre>

<h2 id="java集合">Java集合</h2>

<h3 id="list系">List系</h3>

<p><font color="#9932CC" size=4>ArrayList、LinkedList和Vector之间的区别，他们线程安全吗？不安全怎么解决</font></p>

<pre><code># 区别
- ArrayList和Vector的本质都是Object[]，LinkedLisk本质上是双向链表
- ArrayList和LinkedList是线程不安全的，Vector是线程安全的

# 线程不安全解决办法
- Vetor线程安全，使用synchronized来解决的

Tips：
- 因为ArrayList和LinkedList的底层数据结构不同，所以ArrayList适合更多查找的场景，LinkedList底层是双向链表，所以更加适合插入，删除的场景
</code></pre>

<p><font color="#9932CC" size=4>ArrayList是如何实现动态扩容的</font>
&gt; <strong>链接：</strong><a href="https://blog.jaswine.com/2019/01/24/java18/">源码分析-Java中ArrayList是如何实现数组动态扩容的</a></p>

<pre><code>- ArrayList的本质是Object[]，所以他本质上就是数组的动态扩容
- Java底层的数组扩容就是通过数组拷贝完成的
</code></pre>

<h3 id="map系">Map系</h3>

<p><font color="#9932CC" size=4>Map接口的实现类，简单的说说他们</font>
|类|底层数据结构|特点|是否线程安全|
|:&ndash;|:&ndash;|:&ndash;|:&ndash;|
|HashMap|数组+链表/红黑树|可以使用null作为Key和Value|不安全|
|Hashtable|数组+链表/红黑树|非null的key和value|安全|
|LinkedHashMap|继承HashMap，多维护一个双向链表|同HashMap，有序的|不安全|
|TreeMap|红黑树|有序|不安全|
|Properties|继承hashtable||安全|</p>

<pre><code>- Map接口有如下的实现类:EnumMap,HashMap,Hashtable,TreeMap
</code></pre>

<p><font color="#9932CC" size=4>Map接口实现类之间的区别</font></p>

<pre><code>- HashMap是无序的，LinkedHashMap是有序的
- HashMap是线程不安全的，Hashtable是线程安全的
- HashMap中K,V都可以是null，Hashtable不可以
- TreeMap介意将键值排序输出，默认是升序输出
</code></pre>

<p><font color="#9932CC" size=4>有没有有顺序的Map实现类，如果有，他们是怎么保证有序的</font></p>

<pre><code># 有序Map实现类
- 实现了SortedMap接口的都是有序Map，比如LinkedHashMap，TreeMap

# 保证有序
- LinkedHashMap基于元素进入集合的顺序排序，底层就是多维护一个双向链表
- TreeMap基于元素的固有顺序(由Comparator或者Comparable确定)，底层是红黑树
</code></pre>

<p><font color="#9932CC" size=4>HashMap和Hashtable之间有什么区别</font></p>

<pre><code>- HashMap是线程不安全的，Hashtable是线程安全的
- HashMap的k，v都可以是null，Hashtable不可以
</code></pre>

<p><font color="#9932CC" size=4>HashMap底层原理是什么？存储方式，默认容量是什么？怎么实现扩容的？</font></p>

<pre><code># 底层原理


# 存储方式
- Java8中使用位桶(数组)+链表/红黑树实现
- 链表长度超过阈值(8)时转成红黑树(减少查找时间)

# 扩容
- 本质上就是数组的扩容
</code></pre>

<p><font color="#9932CC" size=4>HashMap是线程安全的吗？为什么？解决办法是什么？原理是什么？</font></p>

<pre><code># 线程安全吗
- 线程不安全

# 为什么

# 解决办法
- 使用Collections.synchronizedMap(new HashMap(...))
- 使用并发包中的ConcurrentHashMap
- 使用Hashtable

# 原理
- 

</code></pre>

<p><font color="#9932CC" size=4>ConcurrentHashMap在1.7和1.8中有什么区别？</font></p>

<pre><code>- 使用Synchronized+CAS+Node+Unsafe来替代Segment+HashEntry+Unsafe
- put()初始化数组大小时1.8不用加锁(使用sizeCtl变量来标记table是不是在初始化，为-1的时候就是正在初始化)
</code></pre>

<p><font color="#9932CC" size=4>poll()和remove()方法的区别？</font></p>

<p><font color="#9932CC" size=4>HashMap和Hashtable之间有什么不同之处</font></p>

<pre><code>- HashMap可以接受null作为k,v;Hashtable不可以
- HashMap是非synchronized的;Hashtable是
</code></pre>

<h3 id="set系">Set系</h3>

<p><font color="#9932CC" size=4>HashSet内部是怎么工作的</font></p>

<pre><code>- HashSet内部使用HashMap来实现的
- HashSet是对value的进行hash计算(因为set中元素不能重复)
</code></pre>

<h3 id="queue系">queue系</h3>

<p><font color="#9932CC" size=4>Java中队列都有哪些，他们之间的区别是什么</font></p>

<table>
<thead>
<tr>
<th align="left"></th>
<th align="left"></th>
<th align="left"></th>
</tr>
</thead>

<tbody>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody>
</table>

<h2 id="java并发编程">Java并发编程</h2>

<h3 id="多线程基础理论">多线程基础理论</h3>

<p><font color="#9932CC" size=4>什么是线程安全？线程不安全的根源是什么？Java是怎么解决的</font></p>

<pre><code># 线程安全
- 一个方法或者实例在多线程环境下使用不会出现问题，这个问题本质上就是共有数据在被并发修改的产生脏写的问题

# 不安全的根源
- 线程不安全的根源是多线程并发的情况下无法保证有序性，原子性和可见性

# Java的解决办法
- Java使用JMM保证了多线程并发的情况下线程之间的有序性和可见性
-- 
- 使用锁来解决原子性问题
</code></pre>

<p><font color="#9932CC" size=4>说说死锁</font></p>

<pre><code># 死锁发生的条件
- 互斥，共享资源x、y只能被一个线程占有
- 占有等待，线程T1占有资源x还在等待资源y
- 不可抢占，其他线程不能抢占T1的资源
- 循环等待，T1和T2互相等待对方释放资源

# 解决死锁
- 一次申请所有锁资源，申请不到就不占有
- 如果申请不到锁资源，主动释放自己身上的锁资源
- 
</code></pre>

<h3 id="java并发方案">Java并发方案</h3>

<p><font color="#9932CC" size=4>怎么打印出线程的栈信息</font></p>

<pre><code>- 使用jstack工具可以看到JVM中相关线程堆栈信息
</code></pre>

<p><font color="#9932CC" size=4>画一下线程生命周期和状态转换图</font></p>

<p><font color="#9932CC" size=4>一个线程两次调用start()方法会怎么样</font></p>

<pre><code>- 会抛出IllegalThreadStateException错误
</code></pre>

<p><font color="#9932CC" size=4>你知道停止一个线程有哪些方法，他们之间都有什么区别</font></p>

<pre><code># 方法
- Thread.stop()
- Thread.interrupt()
- run方法结束(正常停止线程)

# 区别
- stop()在JDK中已经被遗弃，执行stop方法后会立即终止线程，释放当前线程持有锁资源，破坏了对象的一致性
- interrupt()执行后不会立马终止线程，会设置一个中断标记位
</code></pre>

<p><font color="#9932CC" size=4>sleep()和wait()的区别</font>
|wait|sleep|
|:&ndash;|:&ndash;|
|Object的方法|Thread的方法|
|执行的时候释放锁|执行的时候不释放锁|
|只能在同步方法和同步块中使用|可以在任何地方使用|
|无需捕捉异常|需要捕捉异常|
<font color="#9932CC" size=4>讲讲Java同步机制的wait和notify</font></p>

<p><font color="#9932CC" size=4>volatile的原理，作用，能代替锁吗？</font></p>

<pre><code># 作用
- 可以保证多线程情况下的有序性和可见性，不能保证原子性
    -- 有序性是通过禁止指令重排完成的
    -- 可见性是happen-before完成的
- 相当于轻量级的synchronized
- 使用volatile修饰的变量单次读写可以保持原子性，但是不能多次不能

# 原理
- volatile变量被修改的时候，必须强制刷新到主存中(保证线程之间的可见性)
- JMM会对volatile变量限制重排序,是基于JMM的happen-before实现的(保证有序性)
- JVM底层是采用内存屏障来实现的happen-before的

# 结论：不能代替锁
- 只保证了可见性，没有保证原子性
</code></pre>

<p><font color="#9932CC" size=4>JDK1.6对synchronized进行了怎么的优化</font></p>

<pre><code>- 引入四种锁状态(无锁，偏向锁，轻量级锁，重量级锁)，向上膨胀
</code></pre>

<p><font color="#9932CC" size=4>说说ReentrantLock和synchronized的异同吧</font></p>

<pre><code># 同
- 都是协调多线程对象共享对象和变量的访问(同步锁)
- 可重入，同一线程可以多次获得同一个锁
- 保证了可见性和互斥性

# 异
- ReentrantLock是显式的获得、释放锁，synchronized是隐式的
- ReentrantLock可响应中断、可轮回，synchronized是不可以响应中断的，为处理锁的不可用性提供了更高的灵活性
- ReentrantLock是API级别的，synchronized是JVM级别的
- ReentrantLock可以实现公平锁
- ReentrantLock通过Condition可以绑定多个条件
- 底层实现不一样， synchronized是同步阻塞，使用的是悲观并发策略，lock是同步非阻塞，采用的是乐观并发策略
</code></pre>

<p><font color="#9932CC" size=4>Lock和synchronized的区别</font>
|类别|Lock|synchronized|
|:&ndash;|:&ndash;|:&ndash;|
|存在层次|API级别,程序员调用|JVM级别|
|锁的释放|手动释放|jvm自动释放|
|锁的获取|假设A线程获得锁，B线程等待。如果A线程阻塞，B线程会一直等待|分情况而定，Lock有多个锁获取的方式，大致就是可以尝试获得锁，线程可以不用一直等待|
|锁状态|可以判断|无法判断|
|锁类型|可重入、不可中断、非公平|可重入、可判断、可(非)公平|
|性能|大量同步|少量同步|
<font color="#9932CC" size=4>synchronized的原理是什么？一般用在什么地方？(修饰静态和非静态方法有什么区别)</font></p>

<pre><code># 使用
- 修饰实例方法，作用于当前实例加锁，进入同步代码前要获得当前实例的锁
- 修饰静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁
- 修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁

# 原理
- 在同步代码块中：在代码块开始的时候使用monitorenter来获得monitor对象锁，在代码块结束的时候使用monitorexit指令来释放monitor对象锁。
- 在同步方法中：在字节码层面，没有特别的指令来实现被synchronized修饰的方法，而是在class文件中对该方法的access_flag字段中的synchronized标志位置1，表示该方法是同步方法，并使用调用该方法的对象或者该方法所在的class在JVM的内部对象表示class作为锁对象
</code></pre>

<p><font color="#9932CC" size=4>说说你对锁的相关名词的理解</font></p>

<pre><code># 自旋锁
- 当线程A占用锁，线程B拿不到锁的时候就被挂起(阻塞)，自旋锁是线程B不放弃CPU的时间片，在原地一直尝试获取锁

# 无锁 / 偏向锁 / 轻量级锁 / 重量级锁
- 这是锁的四种状态，在对象头中使用字段来标记
- 四种状态随着竞争的情况升级，不可降级
- 这四种状态都不是Java语言中的锁，而是JVM为了提高锁的获取效率而做的优化

-- 无锁--&gt;对象没有被锁定
-- 偏向锁--&gt;一段同步代码被线程所访问，那么线程自动获取锁
-- 轻量级锁--&gt;当锁是偏向锁的时候，被另一个线程访问，偏向锁会升级为轻量级锁，其他线程通过自旋的方式尝试获取锁，不会阻塞，提高性能
-- 重量级锁--&gt;当一个锁是轻量级锁的时候，另外一个线程通过自旋的方式到一定次数的时候还没有获得锁就会进入到阻塞的，这个轻量级锁就会膨胀为重量级锁，其他线程拿不到锁就会进入阻塞

# 分段锁
- 

# 共享锁 / 独享锁
- 共享锁--&gt;锁被多个线程共有
- 独享锁--&gt;锁只可以同时被一个线程占用

# 可重入锁 / 不可重入锁
- 可重入锁--&gt;可重复可递归调用的锁，外层使用了内层还可以使用
- 不可重入锁--&gt;不可重复递归调用，重复使用就会发生死锁

# 公平锁 / 非公平锁
- 公平锁--&gt;多个线程按照申请锁的顺序来获得锁
- 非公平锁--&gt;多个线程不是按照申请锁的顺序来获得锁，可能会饥饿现象

# 悲观锁 / 乐观锁
- 悲观锁--&gt;认为每次去拿数据的时候数据都会被别人修改
- 乐观锁--&gt;在拿数据的时候乐观的认为没有人去修改，但是在修改数据的时候会去验证一下数据有没有被修改
---使用版本号机制或者CAS算法实现
</code></pre>

<p><font color="#9932CC" size=4>说说降低锁竞争的方法</font></p>

<pre><code>- 减少锁持有时间
- 降低锁的请求频率
- 使用带有协调机制的独占锁
</code></pre>

<p><font color="#9932CC" size=4>有哪些无锁的数据结构，他们的实现原理是什么？</font></p>

<p><font color="#9932CC" size=4>cas机制是什么？怎么解决ABA问题</font></p>

<p><font color="#9932CC" size=4>说说Java中常用的线程池模式以及不同线程池的使用场景</font></p>

<p><font color="#9932CC" size=4>线程池关闭的方式有哪些？各自的区别是什么？</font></p>

<pre><code># 方式
- shutdown()
- shutdownNow()

# 区别
- 
</code></pre>

<h3 id="实际问题">实际问题</h3>

<p><font color="#9932CC" size=4>现在有一个第三方接口，有很多线程去调用它获得数据，如何实现每秒钟最多有10个线程同时调用它</font></p>

<p><font color="#9932CC" size=4>用三个线程按顺序打印abc，怎么做到</font></p>

<pre><code>- 使用wait，notify
- 
</code></pre>

<p><font color="#9932CC" size=4>ThreadLocal用过吗？用途是什么，原理是什么，使用的时候有什么注意的吗？</font></p>

<pre><code># 用途
- 

# 原理

# 注意事项
- initialValue()是为了让子类重写的，默认是null。如果get()后又remove()则可能调用一下此方法
- remove()
</code></pre>

<p><font color="#9932CC" size=4>现在让你实现一个并发安全的链表，你怎么实现</font></p>

<p><font color="#9932CC" size=4>多线程如果线程挂住了怎么办</font></p>

<p><font color="#9932CC" size=4>countdownlatch和cyclicbarrier的内部原理和用法，以及相互之间的差别</font></p>

<p><font color="#9932CC" size=4>AbstractQueuedSynchronizer了解多少，讲讲加锁和解锁的流程，独占锁和公平锁加锁有什么不同</font></p>

<p><font color="#9932CC" size=4>简述ConcurrentLinkQueue和LinkedBlockingQueue的用处和不同之处</font></p>

<p><font color="#9932CC" size=4>导致线程死锁的原因，怎么解除线程死锁</font></p>

<p><font color="#9932CC" size=4>多线程(可能不在一台机器上)相互之间要相互等待协调完成某种工作，请问怎么设计</font></p>

<p><font color="#9932CC" size=4>用过读写锁吗？原理是什么，一般在什么场景下使用</font></p>

<p><font color="#9932CC" size=4>什么是多线程环境下的伪共享(false sharing)？</font></p>

<p><font color="#9932CC" size=4>说说你对线程局部变量的理解</font></p>

<h2 id="java异常">Java异常</h2>

<p><font color="#9932CC" size=4>Error和Exception的区别，CheckedException和RuntimeException</font></p>

<p><font color="#9932CC" size=4>说说你知道的运行时异常</font></p>

<h2 id="java注解-泛型-枚举">Java注解，泛型，枚举</h2>

<p><font color="#9932CC" size=4>JDK1.5引入了泛型，泛型的存在是用来解决什么问题</font></p>

<h2 id="java高级特性">Java高级特性</h2>

<p><font color="#9932CC" size=4>反射的原理是什么？反射创建类实例的三种方式是什么？</font></p>

<pre><code></code></pre>

<p><font color="#9932CC" size=4>动态代理有哪些实现方式，你知道他们相应的优缺点吗？</font></p>

<pre><code># 实现方式
- JDK动态代理
- cglib动态代理

# 优缺点
如下
</code></pre>

<p><font color="#9932CC" size=4>JDK的动态代理和cglib的实现有什么区别？以及相应的原理是什么呢？</font>
||JDK|cglib|
|:&ndash;|:&ndash;|:&ndash;|
|区别|只能对实现同一接口的类进行代理|可以对任何类惊醒代理，但是不能对final修饰的类进行代理|
|原理|使用Java反射原理实现的|使用asm的开源工具将代理的类加载进来实现其子类，然后重写相关的方法|</p>
</article>

      

      
    </div>

    
  
  
  <aside class="book-toc fixed">
    <nav id="TableOfContents">
<ul>
<li><a href="#java面试题">Java面试题</a>
<ul>
<li><a href="#java基础">Java基础</a>
<ul>
<li><a href="#java小知识点">Java小知识点</a></li>
<li><a href="#java关键字">Java关键字</a></li>
<li><a href="#逻辑运算">逻辑运算</a></li>
<li><a href="#object">Object</a></li>
<li><a href="#string">String</a></li>
</ul></li>
<li><a href="#java面向对象思想">Java面向对象思想</a></li>
<li><a href="#java-i-o">Java I/O</a></li>
<li><a href="#java集合">Java集合</a>
<ul>
<li><a href="#list系">List系</a></li>
<li><a href="#map系">Map系</a></li>
<li><a href="#set系">Set系</a></li>
<li><a href="#queue系">queue系</a></li>
</ul></li>
<li><a href="#java并发编程">Java并发编程</a>
<ul>
<li><a href="#多线程基础理论">多线程基础理论</a></li>
<li><a href="#java并发方案">Java并发方案</a></li>
<li><a href="#实际问题">实际问题</a></li>
</ul></li>
<li><a href="#java异常">Java异常</a></li>
<li><a href="#java注解-泛型-枚举">Java注解，泛型，枚举</a></li>
<li><a href="#java高级特性">Java高级特性</a></li>
</ul></li>
</ul>
</nav>
  </aside>



  </main>
  
  
  
</body>

</html>
